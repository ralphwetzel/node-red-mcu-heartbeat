<!--
    This code is based on
    
        * 20-inject.html
        * Copyright JS Foundation and other contributors, http://js.foundation
        *
        * Licensed under the Apache License, Version 2.0 (the "License");
        * you may not use this file except in compliance with the License.
        * You may obtain a copy of the License at
        *
        * http://www.apache.org/licenses/LICENSE-2.0
        *
        * Unless required by applicable law or agreed to in writing, software
        * distributed under the License is distributed on an "AS IS" BASIS,
        * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
        * See the License for the specific language governing permissions and
        * limitations under the License.

    Adaptations to node-red-mcu-heartbeat by @ralphwetzel
    Copyright 2022 - 2023 Ralph Wetzel
    https://github.com/ralphwetzel/node-red-mcu-heartbeat
    License: MIT
-->

<!-- This (label) color definition needed to be done 
    a second time @ onpaletteadd (bottom of script!)
-->
<style>
    .heartbeat_label_style {
        fill: salmon
    }
</style>

<script type="text/html" data-template-name="mcu-heartbeat">
    <div class="form-row">
        <label for="node-input-name"><i class="fa fa-tag"></i> <span data-i18n="node-red:common.label.name"></span></label>
        <input type="text" id="node-input-name" data-i18n="[placeholder]node-red:common.label.name">
    </div>

    <div class="form-row">
        <label for="node-input-heartbeat"><i class="fa fa-heartbeat"></i> Heartbeat</label>
        <input type="checkbox" id="node-input-heartbeat" style="display:inline-block; width:15px; vertical-align:baseline;">
        <span>Check connection to MCU every</span>&nbsp;
        <input type="text" id="node-input-pulse" placeholder="5" style="width:45px; height:28px;">&nbsp;
        <span>seconds.</span>
    </div>

    <div class="form-row">
        <label for="node-input-launch"></label>
        <input type="checkbox" id="node-input-launch" style="display:inline-block; width:15px; vertical-align:baseline;">
        <span>Signal flow launch on second output.</span>

        <input type="hidden" id="node-input-outputs">

    </div>

    <div class="form-row node-input-property-container-row">
        <label for="node-input-property-container" style="width: 150px"><i class="fa fa-tag"></i> Inject Configuration</span></label>
        <ol id="node-input-property-container"></ol>
    </div>

    <div class="form-row" id="node-once">
        <label for="node-input-once">&nbsp;</label>
        <input type="checkbox" id="node-input-once" style="display:inline-block; width:15px; vertical-align:baseline;">
        <span data-i18n="node-red:inject.onstart"></span>&nbsp;
        <input type="text" id="node-input-onceDelay" placeholder="0.1" style="width:45px; height:28px;">&nbsp;
        <span data-i18n="node-red:inject.onceDelay"></span>
    </div>

    <div class="form-row">
        <label for=""><i class="fa fa-repeat"></i> <span data-i18n="node-red:inject.label.repeat"></span></label>
        <select id="heartbeat-time-type-select">
            <option value="none" data-i18n="node-red:inject.none"></option>
            <option value="interval" data-i18n="node-red:inject.interval"></option>
<!--
            <option value="interval-time" data-i18n="node-red:inject.interval-time"></option>
            <option value="time" data-i18n="node-red:inject.time"></option>
-->
        </select>
        <input type="hidden" id="node-input-repeat">
        <input type="hidden" id="node-input-crontab">
    </div>

    <div class="form-row heartbeat-time-row hidden" id="heartbeat-time-row-interval">
        <span data-i18n="node-red:inject.every"></span>
        <input id="heartbeat-time-interval-count" class="heartbeat-time-count" value="1">
        <select style="width:100px" id="heartbeat-time-interval-units">
            <option value="s" data-i18n="node-red:inject.seconds"></option>
            <option value="m" data-i18n="node-red:inject.minutes"></option>
            <option value="h" data-i18n="node-red:inject.hours"></option>
        </select><br/>
    </div>

    <div class="form-row heartbeat-time-row hidden" id="heartbeat-time-row-interval-time">
        <span data-i18n="node-red:inject.every"></span> <select style="width:90px; margin-left:20px;" id="heartbeat-time-interval-time-units" class="heartbeat-time-int-count" value="1">
            <option value="1">1</option>
            <option value="2">2</option>
            <option value="3">3</option>
            <option value="4">4</option>
            <option value="5">5</option>
            <option value="6">6</option>
            <option value="10">10</option>
            <option value="12">12</option>
            <option value="15">15</option>
            <option value="20">20</option>
            <option value="30">30</option>
            <option value="0">60</option>
        </select> <span data-i18n="node-red:inject.minutes"></span><br/>
        <span data-i18n="node-red:inject.between"></span> <select id="heartbeat-time-interval-time-start" class="heartbeat-time-times"></select>
        <span data-i18n="node-red:inject.and"></span> <select id="heartbeat-time-interval-time-end" class="heartbeat-time-times"></select><br/>
        <div id="heartbeat-time-interval-time-days" class="heartbeat-time-days" style="margin-top:5px">
            <div style="display:inline-block; vertical-align:top; margin-right:5px;" data-i18n="node-red:inject.on">on</div>
            <div style="display:inline-block;">
                <div>
                    <label><input type='checkbox' checked value='1'/> <span data-i18n="node-red:inject.days.0"></span></label>
                    <label><input type='checkbox' checked value='2'/> <span data-i18n="node-red:inject.days.1"></span></label>
                    <label><input type='checkbox' checked value='3'/> <span data-i18n="node-red:inject.days.2"></span></label>
                </div>
                <div>
                    <label><input type='checkbox' checked value='4'/> <span data-i18n="node-red:inject.days.3"></span></label>
                    <label><input type='checkbox' checked value='5'/> <span data-i18n="node-red:inject.days.4"></span></label>
                    <label><input type='checkbox' checked value='6'/> <span data-i18n="node-red:inject.days.5"></span></label>
                </div>
                <div>
                    <label><input type='checkbox' checked value='0'/> <span data-i18n="node-red:inject.days.6"></span></label>
                </div>
            </div>
        </div>
    </div>

    <div class="form-row heartbeat-time-row hidden" id="heartbeat-time-row-time">
        <span data-i18n="node-red:inject.at"></span> <input type="text" id="heartbeat-time-time" value="12:00"><br/>
        <div id="heartbeat-time-time-days" class="heartbeat-time-days">
            <div style="display:inline-block; vertical-align:top; margin-right:5px;" data-i18n="node-red:inject.on"></div>
            <div style="display:inline-block;">
                <div>
                    <label><input type='checkbox' checked value='1'/> <span data-i18n="node-red:inject.days.0"></span></label>
                    <label><input type='checkbox' checked value='2'/> <span data-i18n="node-red:inject.days.1"></span></label>
                    <label><input type='checkbox' checked value='3'/> <span data-i18n="node-red:inject.days.2"></span></label>
                </div>
                <div>
                    <label><input type='checkbox' checked value='4'/> <span data-i18n="node-red:inject.days.3"></span></label>
                    <label><input type='checkbox' checked value='5'/> <span data-i18n="node-red:inject.days.4"></span></label>
                    <label><input type='checkbox' checked value='6'/> <span data-i18n="node-red:inject.days.5"></span></label>
                </div>
                <div>
                    <label><input type='checkbox' checked value='0'/> <span data-i18n="node-red:inject.days.6"></span></label>
                </div>
            </div>
        </div>
    </div>

    <div class="form-row heartbeat-time-row hidden">
        <input type="hidden" id="node-input-triggerLabel">
    </div>
</script>
<style>
    .heartbeat-time-row {
        padding-left: 110px;
    }
    .heartbeat-time-row:not(#heartbeat-time-row-interval) select {
        margin: 3px 0;
    }
    .heartbeat-time-days label {
        -webkit-user-select: none;
        -khtml-user-select: none;
        -moz-user-select: none;
        -ms-user-select: none;
        user-select: none;
        vertical-align: baseline;
        width: 100px;
    }
    .heartbeat-time-days input {
        width: auto !important;
        vertical-align: baseline !important;
    }
    .heartbeat-time-times {
        width: 90px !important;
    }
    #heartbeat-time-time {
        width: 75px;
        margin-left: 8px;
        margin-bottom: 8px;
    }
    .heartbeat-time-count {
        padding-left: 3px !important;
        width: 80px !important;
    }
</style>

<script type="text/javascript">
(function() {

    const heartbeat_status = {
        idle: {
            text: "idle",
            shape: "ring",
            fill: "grey"
        },
        connected: {
            text: "connected",
            shape: "dot",
            fill: "green"
        },
        lost: {
            text: "disconnected",
            shape: "dot",
            fill: "red"
        }
    }
    
    // We cannot influence the text color when the node is displayed in the flow library.
    // There, the text color is always black - which is looking bad for the MicroMagix theme.
    // Thus we define a different node background color @ registerType (to please the library)
    // and inject a small patch here to change to our desired node background color!
    // The label color finally is set with an additional class @ labelStyle.
    let gNC = RED.utils.getNodeColor;
    RED.utils.getNodeColor = function(type, def) {
        if (type == "mcu-heartbeat") {
            return "#505050";
        }
        return gNC(type, def);
    }

    function resizeDialog(size) {
        size = size || { height: $(".red-ui-tray-content form").height() }
        var rows = $("#dialog-form>div:not(.node-input-property-container-row):visible");
        var height = size.height;
        for (var i=0; i<rows.length; i++) {
            height -= $(rows[i]).outerHeight(true);
        }
        var editorRow = $("#dialog-form>div.node-input-property-container-row");
        height -= (parseInt(editorRow.css("marginTop"))+parseInt(editorRow.css("marginBottom")));
        // height += 16;
        $("#node-input-property-container").editableList('height',height);
    }
    /** Retrieve editableList items (refactored for re-use in the form heartbeat button)*/
    function getProps(el, legacy) {
        var result = {
            props: []
        }
        el.each(function(i) {
            var prop = $(this);
            var p = {
                p:prop.find(".node-input-prop-property-name").typedInput('value')
            };
            if (p.p) {
                p.v = prop.find(".node-input-prop-property-value").typedInput('value');
                p.vt = prop.find(".node-input-prop-property-value").typedInput('type');
                if(legacy) {
                    if (p.p === "payload") { // save payload to old "legacy" property
                        result.payloadType = p.vt;
                        result.payload = p.v;
                        delete p.v;
                        delete p.vt;
                    } else if (p.p === "topic" && p.vt === "str") {
                        result.topic = p.v;
                        delete p.v;
                    }
                }
                result.props.push(p);
            }
        });
        return result;
    }
    /** Perform inject, optionally sending a custom msg (refactored for re-use in the form inject button)*/
    function doinject(node, customMsg) {
        var label = node._def.label.call(node,customMsg?customMsg.__user_heartbeat_props__:undefined);
        if (label.length > 30) {
            label = label.substring(0, 50) + "...";
        }
        label = label.replace(/&/g, "&amp;").replace(/</g, "&lt;").replace(/>/g, "&gt;");
        $.ajax({
            url: "heartbeat/" + node.id,
            type: "POST",
            data: JSON.stringify(customMsg||{}),
            contentType: "application/json; charset=utf-8",
            success: function (resp) {
                RED.notify(node._("node-red:inject.success", { label: label }), { type: "success", id: "heartbeat", timeout: 2000 });
            },
            error: function (jqXHR, textStatus, errorThrown) {
                if (jqXHR.status == 404) {
                    RED.notify(node._("node-red:common.notification.error", { message: node._("node-red:common.notification.errors.not-deployed") }), "error");
                } else if (jqXHR.status == 500) {
                    RED.notify(node._("node-red:common.notification.error", { message: node._("node-red:inject.errors.failed") }), "error");
                } else if (jqXHR.status == 0) {
                    RED.notify(node._("node-red:common.notification.error", { message: node._("node-red:common.notification.errors.no-response") }), "error");
                } else {
                    RED.notify(node._("node-red:common.notification.error", { message: node._("node-red:common.notification.errors.unexpected", { status: jqXHR.status, message: textStatus }) }), "error");
                }
            }
        });
    }
    RED.nodes.registerType('mcu-heartbeat',{
        color: "#C0C0C0",   // only for the flow library
        category: 'MicroMagix',
        defaults: {
            name: {value:""},
            props:{value:[{p:"payload"},{p:"topic",vt:"str"}], validate:function(v, opt) {
                    if (!v || v.length === 0) { return true }
                    for (var i=0;i<v.length;i++) {
                        if (/msg|flow|global/.test(v[i].vt)) {
                            if (!RED.utils.validatePropertyExpression(v[i].v)) {
                                return RED._("node-red:inject.errors.invalid-prop", { prop: 'msg.'+v[i].p, error: v[i].v });
                            }
                        } else if (v[i].vt === "jsonata") {
                            try{ jsonata(v[i].v); }
                            catch(e){
                                return RED._("node-red:inject.errors.invalid-jsonata", { prop: 'msg.'+v[i].p, error: e.message });
                            }
                        } else if (v[i].vt === "json") {
                            try{ JSON.parse(v[i].v); }
                            catch(e){
                                return RED._("node-red:inject.errors.invalid-json", { prop: 'msg.'+v[i].p, error: e.message });
                            }
                        } else if (v[i].vt === "num"){
                            if (!/^[+-]?[0-9]*\.?[0-9]*([eE][-+]?[0-9]+)?$/.test(v[i].v)) {
                                return RED._("node-red:inject.errors.invalid-prop", { prop: 'msg.'+v[i].p, error: v[i].v });
                            }
                        }
                    }
                    return true;
                }
            },
            repeat: {
                value:"", validate: function(v, opt) {
                    if ((v === "") ||
                        (RED.validators.number(v) &&
                         (v >= 0) && (v <= 2147483))) {
                        return true;
                    }
                    return RED._("node-red:inject.errors.invalid-repeat");
                }
            },
            crontab: {value:""},
            once: {value:false},
            onceDelay: {value:0.1},
            topic: {value:""},
            payload: {value:"", validate: RED.validators.typedInput("payloadType", false) },
            payloadType: {value:"date"},
            // heartbeat
            heartbeat: {value: true},
            pulse: {value: 5},
            launch: {value: true},
            outputs: {value: 1},
            triggerLabel: {value: ""}
        },
        icon: 'font-awesome/fa-heartbeat',
        inputs:0,
        outputs:1,
        outputLabels: function(index) {
            var lab = '';

            // if only payload and topic - display payload type
            // if only one property - show it's type
            // if more than one property (other than payload and topic) - show "x properties" where x is the number of properties.
            // this.props will not be an array for legacy heartbeat nodes until they are re-deployed
            //
            var props = this.props;
            if (!Array.isArray(props)) {
                props = [
                    { p:"payload", v: this.payload, vt: this.payloadType },
                    { p:"topic", v: this.topic, vt: "str" }
                ]
            }
            if (props) {
                for (var i=0,l=props.length; i<l; i++) {
                    if (i > 0) lab += "\n";
                    if (i === 5) {
                        lab += "... +"+(props.length-5);
                        break;
                    }
                    lab += props[i].p+": ";

                    var propType = props[i].p === "payload"? this.payloadType : props[i].vt;
                    if (propType === "json") {
                        try {
                            var parsedProp = JSON.parse(props[i].p === "payload"? this.payload : props[i].v);
                            propType = typeof parsedProp;
                            if (propType === "object" && Array.isArray(parsedProp)) {
                                propType = "Array";
                            }
                        } catch(e) {
                            propType = "invalid";
                        }
                    }
                    lab += this._("node-red:inject.label."+propType);
                }
            }
            return lab;
        },
        label: function(customProps) {
            var suffix = "";
            // if fire once then add small indication
            if (this.once) {
                suffix = " ¹";
            }
            // but replace with repeat one if set to repeat
            if ((this.repeat && this.repeat != 0) || this.crontab) {
                suffix = " ↻";
            }
            if (this.name) {
                return this.name+suffix;
            }
            var payload = "";
            var payloadType = "str";
            var topic = "";
            if (customProps) {
                for (var i=0;i<customProps.length;i++) {
                    if (customProps[i].p === "payload") {
                        payload = customProps[i].v;
                        payloadType = customProps[i].vt;
                    } else if (customProps[i].p === "topic") {
                        topic = customProps[i].v;
                    }
                }
            } else {
                payload = this.payload || "";
                payloadType = this.payloadType || "str";
                topic = this.topic || "";
            }
            if (payloadType === "string" ||
                    payloadType === "str" ||
                    payloadType === "num" ||
                    payloadType === "bool" ||
                    payloadType === "json") {
                if ((topic !== "") && ((topic.length + payload.length) <= 32)) {
                    return topic + ":" + payload+suffix;
                } else if (payload.length > 0 && payload.length < 24) {
                    return payload+suffix;
                } else {
                    return this._("node-red:inject.inject")+suffix;
                }
            } else if (payloadType === 'date' || payloadType === 'bin' || payloadType === 'env') {
                if ((topic !== "") && (topic.length <= 16)) {
                    return topic + ":" + this._('node-red:inject.label.'+payloadType)+suffix;
                } else {
                    return this._('node-red:inject.label.'+payloadType)+suffix;
                }
            } else if (payloadType === 'flow' || payloadType === 'global') {
                var key = RED.utils.parseContextKey(payload);
                return payloadType+"."+key.key+suffix;
            } else {
                return this._("node-red:inject.inject")+suffix;
            }
        },
        paletteLabel: "heartbeat",
        labelStyle: function() {
            let style = ["heartbeat_label_style"];
            if (this.name) {
                style.push("node_label_italic")
            }
            return style.join(" ");
        },
        oneditprepare: function() {
            var node = this;
            var payloadType = node.payloadType;

            if (node.payloadType == null) {
                if (node.payload == "") {
                    payloadType = "date";
                } else {
                    payloadType = "str";
                }
            } else if (node.payloadType === 'string' || node.payloadType === 'none') {
                payloadType = "str";
            }

            $("#heartbeat-time-type-select").on("change", function() {
                $("#node-input-crontab").val('');
                var id = $("#heartbeat-time-type-select").val();
                $(".heartbeat-time-row").hide();
                $("#heartbeat-time-row-"+id).show();

                // Scroll down
                var scrollDiv = $("#dialog-form").parent();
                scrollDiv.scrollTop(scrollDiv.prop('scrollHeight'));
                resizeDialog();
            });

            $("#node-input-once").on("change", function() {
                $("#node-input-onceDelay").attr('disabled', !$("#node-input-once").prop('checked'));
            })

            $(".heartbeat-time-times").each(function() {
                for (var i=0; i<24; i++) {
                    var l = (i<10?"0":"")+i+":00";
                    $(this).append($("<option></option>").val(i).text(l));
                }
            });
            $("<option></option>").val(24).text("00:00").appendTo("#heartbeat-time-interval-time-end");
            $("#heartbeat-time-interval-time-start").on("change", function() {
                var start = Number($("#heartbeat-time-interval-time-start").val());
                var end = Number($("#heartbeat-time-interval-time-end").val());
                $("#heartbeat-time-interval-time-end option").remove();
                for (var i=start+1; i<25; i++) {
                    var l = (i<10?"0":"")+i+":00";
                    if (i==24) {
                        l = "00:00";
                    }
                    var opt = $("<option></option>").val(i).text(l).appendTo("#heartbeat-time-interval-time-end");
                    if (i === end) {
                        opt.attr("selected","selected");
                    }
                }
            });

            $(".heartbeat-time-count").spinner({
                //max:60,
                min:1
            });

            var repeattype = "none";
            if (node.repeat != "" && node.repeat != 0) {
                repeattype = "interval";
                var r = "s";
                var c = node.repeat;
                if (node.repeat % 60 === 0) { r = "m"; c = c/60; }
                if (node.repeat % 1440 === 0) { r = "h"; c = c/60; }
                $("#heartbeat-time-interval-count").val(c);
                $("#heartbeat-time-interval-units").val(r);
                $("#heartbeat-time-interval-days").prop("disabled","disabled");
            } else if (node.crontab) {
                var cronparts = node.crontab.split(" ");
                var days = cronparts[4];
                if (!isNaN(cronparts[0]) && !isNaN(cronparts[1])) {
                    repeattype = "time";
                    // Fixed time
                    var time = cronparts[1]+":"+cronparts[0];
                    $("#heartbeat-time-time").val(time);
                    $("#heartbeat-time-type-select").val("s");
                    if (days == "*") {
                        $("#heartbeat-time-time-days input[type=checkbox]").prop("checked",true);
                    } else {
                        $("#heartbeat-time-time-days input[type=checkbox]").removeAttr("checked");
                        days.split(",").forEach(function(v) {
                            $("#heartbeat-time-time-days [value=" + v + "]").prop("checked", true);
                        });
                    }
                } else {
                    repeattype = "interval-time";
                    // interval - time period
                    var minutes = cronparts[0].slice(2);
                    if (minutes === "") { minutes = "0"; }
                    $("#heartbeat-time-interval-time-units").val(minutes);
                    if (days == "*") {
                        $("#heartbeat-time-interval-time-days input[type=checkbox]").prop("checked",true);
                    } else {
                        $("#heartbeat-time-interval-time-days input[type=checkbox]").removeAttr("checked");
                        days.split(",").forEach(function(v) {
                            $("#heartbeat-time-interval-time-days [value=" + v + "]").prop("checked", true);
                        });
                    }
                    var time = cronparts[1];
                    var timeparts = time.split(",");
                    var start;
                    var end;
                    if (timeparts.length == 1) {
                        // 0 or 0-10
                        var hours = timeparts[0].split("-");
                        if (hours.length == 1) {
                            if (hours[0] === "") {
                                start = "0";
                                end = "0";
                            }
                            else {
                                start = hours[0];
                                end = Number(hours[0])+1;
                            }
                        } else {
                            start = hours[0];
                            end = Number(hours[1])+1;
                        }
                    } else {
                        // 23,0 or 17-23,0-10 or 23,0-2 or 17-23,0
                        var startparts = timeparts[0].split("-");
                        start = startparts[0];

                        var endparts = timeparts[1].split("-");
                        if (endparts.length == 1) {
                            end = Number(endparts[0])+1;
                        } else {
                            end = Number(endparts[1])+1;
                        }
                    }
                    $("#heartbeat-time-interval-time-end").val(end);
                    $("#heartbeat-time-interval-time-start").val(start);

                }
            } else {
                $("#heartbeat-time-type-select").val("none");
            }

            $(".heartbeat-time-row").hide();
            $("#heartbeat-time-type-select").val(repeattype);
            $("#heartbeat-time-row-"+repeattype).show();

            /* */

            var eList = $('#node-input-property-container').css('min-height','120px').css('min-width','450px');

            eList.editableList({
                buttons: [
                    
                    // *** ToDo: Investigate if possible to implement for mcu
                    
                    // {
                    //     id: "node-heartbeat-test-heartbeat-button",
                    //     label: node._("node-red:inject.injectNow"),
                    //     click: function(e) {
                    //         var items = eList.editableList('items');
                    //         var props = getProps(items);
                    //         var m = {__user_heartbeat_props__: props.props};
                    //         doinject(node, m);
                    //     }
                    // }

                ],
                addItem: function(container,i,opt) {
                    var prop = opt;
                    if (!prop.hasOwnProperty('p')) {
                        prop = {p:"",v:"",vt:"str"};
                    }
                    container.css({
                        overflow: 'hidden',
                        whiteSpace: 'nowrap'
                    });
                    var row = $('<div/>').appendTo(container);

                    var propertyName = $('<input/>',{class:"node-input-prop-property-name",type:"text"})
                        .css("width","30%")
                        .appendTo(row)
                        .typedInput({types:['msg']});

                    $('<div/>',{style: 'display:inline-block; padding:0px 6px;'})
                        .text('=')
                        .appendTo(row);

                    var propertyValue = $('<input/>',{class:"node-input-prop-property-value",type:"text"})
                        .css("width","calc(70% - 30px)")
                        .appendTo(row)
                        .typedInput({default:prop.vt || 'str',types:['flow','global','str','num','bool','json','bin','date','jsonata','env','msg']});

                    propertyName.typedInput('value',prop.p);
                    propertyValue.typedInput('value',prop.v);
                },
                removable: true,
                sortable: true
            });
            $('#node-heartbeat-test-heartbeat-button').css("float", "right").css("margin-right", "unset");

            if (RED.nodes.subflow(node.z)) {
                $('#node-heartbeat-test-heartbeat-button').attr("disabled",true);
            }

            if (!node.props) {
                var payload = {
                    p:'payload',
                    v: node.payload ? node.payload : '',
                    vt:payloadType ? payloadType : 'date'
                };
                var topic = {
                    p:'topic',
                    v: node.topic ? node.topic : '',
                    vt:'str'
                }
                node.props = [payload,topic];
            }

            for (var i=0; i<node.props.length; i++) {
                var prop = node.props[i];
                var newProp = { p: prop.p, v: prop.v, vt: prop.vt };
                if (newProp.v === undefined) {
                    if (prop.p === 'payload') {
                        newProp.v = node.payload ? node.payload : '';
                        newProp.vt = payloadType ? payloadType : 'date';
                    } else if (prop.p === 'topic' && prop.vt === "str") {
                        newProp.v =  node.topic ? node.topic : '';
                    }
                }
                if (newProp.vt === "string") {
                    // Fix bug in pre 2.1 where an old heartbeat node might have
                    // a migrated rule with type 'string' not 'str'
                    newProp.vt = "str";
                }
                eList.editableList('addItem',newProp);
            }

            $("#heartbeat-time-type-select").trigger("change");
            $("#heartbeat-time-interval-time-start").trigger("change");

        },
        oneditsave: function() {
            var repeat = "";
            var crontab = "";
            var type = $("#heartbeat-time-type-select").val();
            if (type == "none") {
                // nothing
            } else if (type == "interval") {
                var count = $("#heartbeat-time-interval-count").val();
                var units = $("#heartbeat-time-interval-units").val();
                if (units == "s") {
                    repeat = count;
                } else {
                    if (units == "m") {
                        //crontab = "*/"+count+" * * * "+days;
                        repeat = count * 60;
                    } else if (units == "h") {
                        //crontab = "0 */"+count+" * * "+days;
                        repeat = count * 60 * 60;
                    }
                }
            } else if (type == "interval-time") {
                repeat = "";
                var count = $("#heartbeat-time-interval-time-units").val();
                var startTime = Number($("#heartbeat-time-interval-time-start").val());
                var endTime = Number($("#heartbeat-time-interval-time-end").val());
                var days = $('#heartbeat-time-interval-time-days input[type=checkbox]:checked').map(function(_, el) {
                    return $(el).val()
                }).get();
                if (days.length == 0) {
                    crontab = "";
                } else {
                    if (days.length == 7) {
                        days="*";
                    } else {
                        days = days.join(",");
                    }
                    var timerange = "";
                    if (endTime == 0) {
                        timerange = startTime+"-23";
                    } else if (startTime+1 < endTime) {
                        timerange = startTime+"-"+(endTime-1);
                    } else if (startTime+1 == endTime) {
                        timerange = startTime;
                    } else {
                        var startpart = "";
                        var endpart = "";
                        if (startTime == 23) {
                            startpart = "23";
                        } else {
                            startpart = startTime+"-23";
                        }
                        if (endTime == 1) {
                            endpart = "0";
                        } else {
                            endpart = "0-"+(endTime-1);
                        }
                        timerange = startpart+","+endpart;
                    }
                    if (count === "0") {
                        crontab = count+" "+timerange+" * * "+days;
                    } else {
                        crontab = "*/"+count+" "+timerange+" * * "+days;
                    }
                }
            } else if (type == "time") {
                var time = $("#heartbeat-time-time").val();
                var days = $('#heartbeat-time-time-days  input[type=checkbox]:checked').map(function(_, el) {
                    return $(el).val()
                }).get();
                if (days.length == 0) {
                    crontab = "";
                } else {
                    if (days.length == 7) {
                        days="*";
                    } else {
                        days = days.join(",");
                    }
                    var parts = time.split(":");
                    if (parts.length === 2) {
                        repeat = "";
                        parts[1] = ("00" + (parseInt(parts[1]) % 60)).substr(-2);
                        parts[0] = ("00" + (parseInt(parts[0]) % 24)).substr(-2);
                        crontab = parts[1]+" "+parts[0]+" * * "+days;
                    }
                    else { crontab = ""; }
                }
            }

            $("#node-input-repeat").val(repeat);
            $("#node-input-crontab").val(crontab);

            /* Gather the properties */
            var items = $("#node-input-property-container").editableList('items');
            delete this.payloadType;
            delete this.payload;
            this.topic = "";
            var result = getProps(items, true);
            this.props = result.props;
            if(result.hasOwnProperty('payloadType')) { this.payloadType = result.payloadType; };
            if(result.hasOwnProperty('payload')) { this.payload = result.payload; };
            if(result.hasOwnProperty('topic')) { this.topic = result.topic; };

            // heartbeat
            {
                let outs = ($("#node-input-launch").prop('checked') == true) ? 2 : 1;
                if (this.outputs !== outs) {
                    $("#node-input-outputs").val(outs);
                }

                // To prepare the trigger feedback!
                let lbl = this._def.label.call(this);
                // let lbl = this._def.label();
                if (lbl.length > 30) {
                    lbl = lbl.substring(0, 50) + "...";
                }
                lbl = lbl.replace(/&/g, "&amp;").replace(/</g, "&lt;").replace(/>/g, "&gt;");
                $("#node-input-triggerLabel").val(lbl);
            }
        },
        button: {
            enabled: function() {
                return (this.connected === true);
            },
            onclick: function () {
                if (this.connected) {

                    $.ajax({
                        url: "heartbeat/" + this.id,
                        type: "POST",
                        data: JSON.stringify({}),
                        contentType: "application/json; charset=utf-8",
                        success: function (resp) {
                        },
                        error: function (jqXHR, textStatus, errorThrown) {
                        }
                    });


                }
            }
        },
        // get status() {
        //     return this._status;
        // },
        // set status(s) {

        //     console.log("@get status: " + s);

        //     let node = this;
        //     node._status = s;

        //     // The MCU will regularly update the status with "green / connected".
        //     // We take this as an indicator that we're connected.
        //     // The ping_timer resets this to "Lost" & later "Idle" in case no updat arrives.

        //     if (s?.fill == "green") {
        //         node.connected = true;
        //         // node.animation_status = msg;

        //         if (node.ping_timer) {
        //             clearTimeout(node.ping_timer);
        //         }

        //         node.ping_timer = setTimeout(() => {

        //             node.ping_timer = setTimeout(() => {
        //                 node.connected = false;
        //                 node.status = heartbeat_status.idle;
        //                 node.dirtyStatus = true;
        //                 node.dirty = true;
        //                 RED.view.redraw();
        //             }, 5000);

        //             node.connected = false;
        //             node.status = heartbeat_status.lost;
        //             node.dirtyStatus = true;
        //             node.dirty = true;
        //             RED.view.redraw();

        //         }, (node.pulse * 1000) + 1000);

        //     }

        // },
        onadd: function() {
            this.connected = false;
            this.status = heartbeat_status.idle;

        },
        oneditresize: resizeDialog,

        // micromagix theme
        onpaletteadd: function(def) {
            let pn = $(".red-ui-palette-node[data-palette-type='"+this.type+"']");
            pn?.find(".red-ui-palette-label")?.css({"color": "salmon"});

        },
        // labelStyle: "heartbeat_label_style"
    });

    // RED.events.on('nodes:add', function(n) {

    //     if (n.type === "mcu-heartbeat") {

    //         let node = n;

    //         delete n.status;

    //         Object.defineProperty(node, "status", {

    //             get() {
    //                 return node._status;
    //             },
    //             set(s) {

    //                 console.log("@set status: " + s);

    //                 node._status = s;

    //                 // The MCU will regularly update the status with "green / connected".
    //                 // We take this as an indicator that we're connected.
    //                 // The ping_timer resets this to "Lost" & later "Idle" in case no further update arrives.

    //                 if (s?.fill == "green") {
    //                     node.connected = true;
    //                     // node.animation_status = msg;

    //                     if (node.ping_timer) {
    //                         clearTimeout(node.ping_timer);
    //                     }

    //                     node.ping_timer = setTimeout(() => {

    //                         node.ping_timer = setTimeout(() => {
    //                             node.connected = false;
    //                             node.status = heartbeat_status.idle;
    //                             node.dirtyStatus = true;
    //                             node.dirty = true;
    //                             RED.view.redraw();
    //                         }, 5000);

    //                         node.connected = false;
    //                         node.status = heartbeat_status.lost;
    //                         node.dirtyStatus = true;
    //                         node.dirty = true;
    //                         RED.view.redraw();

    //                     }, (node.pulse * 1000) + 1000);

    //                 } else {
    //                     node.connected = false
    //                 }
    //                 RED.view.redraw();
    //             }
    //         });

    //         console.log(n);

    //     }
    // });

    RED.comms.subscribe("status/#", function (topic, msg) {
        var parts = topic.split("/");
        var node = RED.nodes.node(parts[1]);
        if (node && node.type == "mcu-heartbeat") {
            
            // The MCU will regularly update the status with "green / connected".
            // We take this as an indicator that we're connected.
            // The ping_timer resets this to "Lost" & later "Idle" in case no further update arrives.
            
            if (msg?.fill == "green") {
                node.connected = true;
                // node.animation_status = msg;

                if (node.ping_timer) {
                    clearTimeout(node.ping_timer);
                }

                node.ping_timer = setTimeout(() => {

                    node.ping_timer = setTimeout(() => {
                        node.connected = false;
                        node.status = heartbeat_status.idle;
                        node.dirtyStatus = true;
                        node.dirty = true;
                        RED.view.redraw();
                    }, 5000);

                    node.connected = false;
                    node.status = heartbeat_status.lost;
                    node.dirtyStatus = true;
                    node.dirty = true;
                    RED.view.redraw();

                }, (node.pulse * 1000) + 1000);

                // if (node.animation_timer) {
                //     clearTimeout(node.animation_timer);
                // }
                // node.animation_status.shape = "ring";

                // node.animation_timer = setInterval(() => {
                //     node.animation_status.shape = node.animation_status.shape == "ring" ? "dot" : "ring";
                //     node.status = msg;
                //     node.dirtyStatus = true;
                //     node.dirty = true;
                //     RED.view.redraw();
                // }, 1000);

            } else {
                node.connected = false;
            }

            RED.view.redraw();
        }
    });
    
})();
</script>
